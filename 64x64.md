## Base64x64 integer (int)

The Swarm protocol uses lots of ids, timestamps and pre-defined constants.
The unifying format for all of those is a 64 bit integer.
Shorter ints don't have the numbering capacity, while free-form strings are way too expensive (especially Unicode).
Hence, `int64_t` (`long` in Java).
Unfortunately, JavaScript does not have 64-bit integers and JavaScript numbers are [dangerous to use][snowflake] in this context.
Hence, Swarm employs a string-based serialization of 64-bit ints defined by the following requirements:

1. the serialized format better be human-readable (to some degree), it should be used in URLs and paths with no additional recoding,
2. the natural alphanumeric ordering of strings must be the same as the original numeric order of integers (as Swarm does lots of causality-and-order comparisons for ids and timestamps),
3. full 64 bits is a bit too much sometimes, so a variable-length encoding is a must (see Google's [varints][varint])

These three requirements are met by our special Base64x64 encoding:

1. 64-bit numbers are serialized as one to ten Base64 chars (10x6=60, 4 bits are reserved),
2. our Base64 variety is `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~` (non-standard, because standard [Base64][base64] varieties do not go in the ASCII order thus breaking the ordering),
3. *tailing* zeroes are skipped, e.g. `1230000000` is shortened to `123`.

The tail-skip rule is a bit counter-intuitive, as the normal [Arabic notation][arab] skips *leading* zeroes, e.g. Arabic 0000123 is 123.
This way, the numeric order of `int64_t` matches the alphanumeric order of a Base64x64 string, which is not the case with Arabic numbers.

Swarm uses uniform 64x64 numbers for:

* variable-precision timestamps,
* replica ids and
* predefined constants.

Variable-precision timestamps have the `MMDHmSssnn` format.
Ten Base64 chars encode months-since-epoch, days, hours, minutes, seconds, milliseconds and an additional sequence number.
The resulting resolution is ~4mln timestamps per second, which is often excessive.
It is OK to shorten timestamps by zeroing the tail (sequence number, milliseconds, etc).
For example, `1CQAneD` is 7 chars and `1CQAn` is 5 chars (`MMDHm`, no seconds - Fri May 27 20:50:00 UTC 2016).
The variable-precision notation behaves a lot like the e-notation here (i.e. `9.22e18`, not `9223372036854775807`).

We use Gregorian calendar and not milliseconds-since-epoch because Swarm timestamps are [hybrid][hybrid] (logical, calendar-aware).
Intuitive understanding of timestamps is more important for us than easy calculation of time intervals.
The resulting bit loss is tolerable (no month is 64 days long).
All numbers starting with `~` are "abnormal", i.e. certainly not timestamps.

[Replica ids](replica.md) are hierarchical, e.g. `X` is a parent of `Xyz1`.
Tailing zeroes and variable lengths save space there too.

Predefined constants are simply strings, 1 to 10 character long, with no numeral meaning.

The variable-length trick provides significant savings when Base64x64 numbers are concatenated.
For example, a full-form specifier has 4 logical timestamps, thus eight 64-bit integers (4x2x64=512 bits in binary).
Still, its Base64x64 can be as short as `#test.db@1CQC2-R:~on-Rgritzko01` (31 chars, 248 bits).
Just for comparison, one 64-bit integer is up to 19 decimal characters (`9223372036854775807`) or 16 hex characters (`7FFFFFFFFFFFFFFF`), thus eight integers are up to 152 and 128 chars respectively, plus separators.

So, Base64x64 is like varint, but for text-based formats and it preserves the ordering. It is mostly used for timestamps and identifiers.

[varint]: https://developers.google.com/protocol-buffers/docs/encoding#varints
[snowflake]: https://dev.twitter.com/overview/api/twitter-ids-json-and-snowflake
[hybrid]: https://www.cse.buffalo.edu/tech-reports/2014-04.pdf
[base64]: https://tools.ietf.org/html/rfc4648#page-5
[arab]: https://en.wikipedia.org/wiki/Arabic_numerals
