# Stamp array (ids)

An id is the most common piece of Swarm metadata.
Efficient id compression thus greatly reduces the overhead.
Id arrays must satisfy the following requirements:

* naturally, effortless iteration
* fast seeks by the offset (offset-to-id)
* fast finds by the id (id-to-offset)
* efficient compression (using id similarity)
* readability/debuggability
* minimal overhead in higher-level langs (object tax)

The solution is to compress intervals of similar ids into *runs*.
That way, we are still using a simple data structure (array/string).
Still, we can inspect it on run at a time, which greatly increases the speed of seek, search and iteration.

A run consists of the *head* id and a *body*.
We simply extend the timestamp syntax to serialize runs.
Each run body is either a numeral or a sequence of fixed-width elements separated by one of `;,'"`.
For example: `@0;8` (a run of eight zeros, see 2.1).

1. run head compression modes
    1. full uncompressed id, e.g. `@1CQKneD-Rgritzko01`
    2. same-origin id, e.g. `@1CQKneD-` -- simply use the origin from the previous id
    3. frequent-origin id, e.g. `@1CQKneD-Rgritzko01>5` -- simply remembers this origin under shortcut 5
    4. mentioned-origin, e.g. `@1CQKneD<5` -- reuses a frequent origin (number 5)
2. run body compression modes
    1. same-value run, e.g. `;8` -- repeat eight times
    2. close-value run, e.g. `,abc` -- replace the last timestamp character
    3. less-close-value run, e.g. `'aaBBcc` -- replace two last characters
    4. incremental run, e.g. `"482` -- add to the last timestamp character
        * overflow is carried over to the previous timestamp char
        * change is limited to the two last characters of the head
        * the 7th timestamp character MMDHmS**s**snn is considered 4 bits wide as milliseconds (ss) change from 0 to 999 (`00..Fc`)  

Head and body compression can be combined in every possible way: `@1CQKneD-,abc`, `@<"A58`, etc.

While encoding algorithms may vary, the decoder is completely deterministic in following the definitions.

Somebody may ask, aren't we doing the job of gzip?
Not exactly, because our goal is to have an iterable in-memory container in many programming languages, including JavaScript.
So, we use a regex-parseable compression method for Base64 strings.
The 2.4 incremental run method is particularly tailored to compress monotonously increasing sequences of timestamps generated by typing in collaborative editors.
